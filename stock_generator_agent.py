# -*- coding: utf-8 -*-
"""Stock Generator Agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qskNwW63ZqFHD_WIlcow6m5GaoapuYck
"""

# app.py
import streamlit as st
import numpy as np
import pandas as pd
import torch
from torch.utils.data import TensorDataset, DataLoader

from data import load_stock_data, prepare_data
from model import StockLSTM, train_model, predict

st.set_page_config(page_title="LSTM Stock Forecaster", layout="wide")

st.title("LSTM Stock Price Predictor (PyTorch + Streamlit)")
st.write("Educational demo – not financial advice.")

# Sidebar controls
ticker = st.sidebar.text_input("Ticker", value="AAPL")
period = st.sidebar.selectbox("History period", ["1y", "2y", "5y", "max"], index=2)
interval = st.sidebar.selectbox("Interval", ["1d", "1h", "30m", "15m"], index=0)
seq_len = st.sidebar.slider("Sequence length", 20, 120, 60, step=5)
epochs = st.sidebar.slider("Epochs", 1, 50, 10)
hidden_size = st.sidebar.slider("Hidden size", 16, 256, 64, step=16)
num_layers = st.sidebar.slider("LSTM layers", 1, 4, 2)
batch_size = st.sidebar.slider("Batch size", 16, 256, 64, step=16)
device = "cuda" if torch.cuda.is_available() else "cpu"

if st.sidebar.button("Run"):
    with st.spinner("Downloading data..."):
        df = load_stock_data(ticker, period=period, interval=interval)

    st.subheader("Historical Close Prices")
    st.line_chart(df["Close"])  # Streamlit uses index as x, series as y [web:41]

    X_train, y_train, X_test, y_test, scaler = prepare_data(df, seq_len=seq_len)
    st.write(f"Train samples: {len(X_train)}, Test samples: {len(X_test)}")

    # DataLoaders
    train_ds = TensorDataset(
        torch.tensor(X_train, dtype=torch.float32),
        torch.tensor(y_train, dtype=torch.float32)
    )
    train_loader = DataLoader(train_ds, batch_size=batch_size, shuffle=True)

    model = StockLSTM(
        input_size=1,
        hidden_size=hidden_size,
        num_layers=num_layers,
        dropout=0.2 if num_layers > 1 else 0.0
    )

    st.write(f"Training on device: **{device}**")
    with st.spinner("Training model..."):
        model = train_model(model, train_loader, num_epochs=epochs, lr=1e-3, device=device)

    # Predictions on test set
    preds_scaled = predict(model, X_test, device=device)
    # inverse transform
    preds = scaler.inverse_transform(preds_scaled)
    y_test_inv = scaler.inverse_transform(y_test)

    # Build a dataframe for plotting
    test_index = df.index[-len(y_test):]
    pred_df = pd.DataFrame({
        "Actual": y_test_inv.flatten(),
        "Predicted": preds.flatten()
    }, index=test_index)

    st.subheader("Test set – Actual vs Predicted Close")
    st.line_chart(pred_df)

    # One-step-ahead forecast using last seq_len points
    last_seq = df[["Close"]].values[-seq_len:]
    last_scaled = scaler.transform(last_seq).reshape(1, seq_len, 1)
    next_scaled = predict(model, last_scaled, device=device)[0, 0]
    next_price = scaler.inverse_transform([[next_scaled]])[0, 0]

    st.subheader("Next-step forecast")
    st.write(f"Next predicted close for **{ticker}**: {next_price:.2f}")